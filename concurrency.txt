std::this_thread::yield
std::this_thread::get_id
std::this_thread::sleep_for
std::this_thread::sleep_until

async: may start or not

future<>.get(): if not finished yet, blocked and get result
without calling get(), there is no guarantee that future<> will ever be called.

policy:
std::launch::async, may throw std::system_error (if not possible to async )

std::launch::async && std::launch::deferred
即使没有 future<>.get(), async 一定会执行， defer可能不执行

后台线程中抛异常：可以catch
future<>.get()只能调用1次，之后是UB

Waiting and Polling and future.get()

-- 强制启动线程 --
.get(): 只能1次
.wait(): 可以调用多次
-- 以下两个不返回std::future_status， 不强制启动线程 --
.wait_for(*): 至多等待 *
.wait_until(*): 等到时间点*

future_status::deferred 	The function to calculate the result has not been started yet
future_status::ready 	The result is ready (finished/returned)
future_status::timeout 	The timeout has expired 

---

实现 1 个惰性求值


Class thread doesn’t have a launch policy.
The C++ standard library always tries to start the passed functionality in a new  thread.
If this  isn’t   possible, it throws a std::system_error with the error code resource_unavailable_try_again.

lifetime

std::terminate()
std::exception_ptr eptr;
std::current_exception();

std::thread::detach:
Separates the thread of execution from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits. 
detached thread: 任由其执行，失去对其的控制，线程结束后资源自动回收，注意不要让detached thread access lifetime 已经过期的对象/资源，所以尽量不要传引用


