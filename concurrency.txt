std::this_thread::yield
std::this_thread::get_id
std::this_thread::sleep_for
std::this_thread::sleep_until

async: may start or not

future<>.get(): if not finished yet, blocked and get result
without calling get(), there is no guarantee that future<> will ever be called.

policy:
std::launch::async, may throw std::system_error (if not possible to async )

std::launch::async && std::launch::deferred
即使没有 future<>.get(), async 一定会执行， defer可能不执行

后台线程中抛异常：可以catch
future<>.get()只能调用1次，之后是UB

Waiting and Polling and future.get()

-- 强制启动线程 --
.gwt(): 只能1次
.wait(): 是不是可以调用多次
-- 以下两个不返回std::future_statu， 不强制启动线程 --
.wait_for(*): 至多等待 *
.wait_until(*): 等到时间点*

future_status::deferred 	The function to calculate the result has not been started yet
future_status::ready 	The result is ready (finished/returned)
future_status::timeout 	The timeout has expired 

---

实现 1 个惰性求值





安安子 /cpp

int print10(char c)
{
	std::default_random_engine dre(c);
	std::uniform_int_distribution<int> id(10, 1000);
	for (int i = 0; i < 10; ++i)
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(id(dre)));
		std::cout.put(c).flush();
	}
	return c;
}

int main()
{
	char ch = 'A';
	auto fA = std::async([&] {print10(ch); });
	ch = 'B';
	auto fB = std::async([&] {print10(ch); });

	if (fA.wait_for(std::chrono::seconds(0)) != std::future_status::deferred ||
		fB.wait_for(std::chrono::seconds(0)) != std::future_status::deferred)
	{
		while (fA.wait_for(std::chrono::seconds(0)) != std::future_status::ready&&
			fB.wait_for(std::chrono::seconds(0)) != std::future_status::ready)
		{
			std::this_thread::yield();
		}
		cout.put('\n').flush();
	}
	try
	{
		fA.get();
		fB.get();
	}
	catch (const exception& e)
	{
		cout<<"excep"<<endl;
	}
	return 0;
}